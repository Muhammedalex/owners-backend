# Notification Realtime Setup Guide

## Overview

This guide explains how to set up real-time notifications in your React application using Laravel Broadcasting.

## Backend Setup

### 1. Broadcasting Configuration

The backend uses **Laravel Reverb** - Laravel's native WebSocket server for real-time broadcasting.

**Configuration Files:**
- `config/broadcasting.php` - Broadcasting configuration
- `config/reverb.php` - Reverb server configuration
- `routes/channels.php` - Channel authorization

**Environment Variables (.env):**

These values are **automatically generated** when you run `php artisan reverb:install`. The command will add them to your `.env` file.

If you need to generate them manually, you can run:
```bash
php artisan reverb:install
```

Or add them manually to your `.env` file:
```env
BROADCAST_CONNECTION=reverb

# Reverb Configuration (auto-generated by reverb:install)
REVERB_APP_ID=123456                    # Random number (100000-999999)
REVERB_APP_KEY=abcdefghijklmnopqrst     # Random 20-character string
REVERB_APP_SECRET=zyxwvutsrqponmlkjihg  # Random 20-character string
REVERB_HOST=localhost
REVERB_PORT=8080
REVERB_SCHEME=http
```

**Note:** The `REVERB_APP_ID`, `REVERB_APP_KEY`, and `REVERB_APP_SECRET` are randomly generated by Laravel when you run `reverb:install`. You don't need to get them from anywhere - just run the install command!

### 2. Broadcasting Routes

Broadcasting routes are automatically registered in `bootstrap/app.php`.

**Broadcasting Endpoint:**
```
POST /broadcasting/auth
```

This endpoint is used by the frontend to authenticate private channels.

## Frontend Setup (React)

### 1. Install Dependencies

```bash
npm install laravel-echo pusher-js
```

### 2. Configure Laravel Echo

**File: `src/config/echo.js`**

```javascript
import Echo from 'laravel-echo';
import Pusher from 'pusher-js';

// Configure Pusher (Reverb uses Pusher protocol)
window.Pusher = Pusher;

// Create Echo instance
const echo = new Echo({
  broadcaster: 'reverb',
  key: import.meta.env.VITE_REVERB_APP_KEY,
  wsHost: import.meta.env.VITE_REVERB_HOST,
  wsPort: import.meta.env.VITE_REVERB_PORT ?? 80,
  wssPort: import.meta.env.VITE_REVERB_PORT ?? 443,
  forceTLS: (import.meta.env.VITE_REVERB_SCHEME ?? 'https') === 'https',
  enabledTransports: ['ws', 'wss'],
  authorizer: (channel, options) => {
    return {
      authorize: (socketId, callback) => {
        // Use your API client to authenticate
        apiClient.post('/broadcasting/auth', {
          socket_id: socketId,
          channel_name: channel.name
        })
        .then(response => {
          callback(null, response.data);
        })
        .catch(error => {
          callback(error);
        });
      }
    };
  }
});

export default echo;
```

### 3. Environment Variables

**File: `.env`**

```env
VITE_REVERB_APP_KEY=my-app-key
VITE_REVERB_HOST=localhost
VITE_REVERB_PORT=8080
VITE_REVERB_SCHEME=http
```

**For production:**
```env
VITE_REVERB_APP_KEY=my-app-key
VITE_REVERB_HOST=your-domain.com
VITE_REVERB_PORT=443
VITE_REVERB_SCHEME=https
```

### 4. Create Notification Hook

**File: `src/hooks/useNotifications.js`**

```javascript
import { useEffect, useState } from 'react';
import { useQuery, useQueryClient } from '@tanstack/react-query';
import echo from '../config/echo';
import { notificationApi } from '../api/notifications';

export function useNotifications() {
  const queryClient = useQueryClient();
  const [unreadCount, setUnreadCount] = useState(0);

  // Fetch notifications
  const { data: notifications, isLoading } = useQuery({
    queryKey: ['notifications'],
    queryFn: () => notificationApi.list(),
  });

  // Fetch unread count
  const { data: countData } = useQuery({
    queryKey: ['notifications', 'unread-count'],
    queryFn: () => notificationApi.getUnreadCount(),
    refetchInterval: 30000, // Poll every 30 seconds as fallback
  });

  // Listen for real-time notifications
  useEffect(() => {
    const user = JSON.parse(localStorage.getItem('user')); // Get from your auth store
    if (!user) return;

    const channel = echo.private(`user.${user.id}`);

    // Listen for new notifications
    channel.listen('.notification.created', (data) => {
      // Invalidate queries to refetch
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
      queryClient.invalidateQueries({ queryKey: ['notifications', 'unread-count'] });
      
      // Update unread count
      setUnreadCount(prev => prev + 1);
      
      // Show browser notification (optional)
      if (Notification.permission === 'granted') {
        new Notification(data.notification.title, {
          body: data.notification.message,
          icon: data.notification.icon,
        });
      }
    });

    // Cleanup
    return () => {
      echo.leave(`user.${user.id}`);
    };
  }, [queryClient]);

  // Update unread count when countData changes
  useEffect(() => {
    if (countData?.data?.unread_count !== undefined) {
      setUnreadCount(countData.data.unread_count);
    }
  }, [countData]);

  return {
    notifications: notifications?.data || [],
    unreadCount,
    isLoading,
  };
}
```

### 5. Create Notification API Client

**File: `src/api/notifications.js`**

```javascript
import apiClient from './client';

export const notificationApi = {
  list: (params = {}) => {
    return apiClient.get('/notifications', { params });
  },

  getLatest: (limit = 10) => {
    return apiClient.get('/notifications/latest', { params: { limit } });
  },

  getUnreadCount: () => {
    return apiClient.get('/notifications/unread-count');
  },

  markAsRead: (id) => {
    return apiClient.post(`/notifications/${id}/read`);
  },

  markAsUnread: (id) => {
    return apiClient.post(`/notifications/${id}/unread`);
  },

  markAllAsRead: () => {
    return apiClient.post('/notifications/mark-all-read');
  },

  delete: (id) => {
    return apiClient.delete(`/notifications/${id}`);
  },

  deleteAllRead: () => {
    return apiClient.delete('/notifications/delete-all-read');
  },
};
```

### 6. Create Notification Component

**File: `src/components/NotificationBell.js`**

```javascript
import { useNotifications } from '../hooks/useNotifications';
import { notificationApi } from '../api/notifications';
import { useMutation, useQueryClient } from '@tanstack/react-query';

export function NotificationBell() {
  const { notifications, unreadCount } = useNotifications();
  const queryClient = useQueryClient();
  const [isOpen, setIsOpen] = useState(false);

  const markAsReadMutation = useMutation({
    mutationFn: notificationApi.markAsRead,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
      queryClient.invalidateQueries({ queryKey: ['notifications', 'unread-count'] });
    },
  });

  const markAllAsReadMutation = useMutation({
    mutationFn: notificationApi.markAllAsRead,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['notifications'] });
      queryClient.invalidateQueries({ queryKey: ['notifications', 'unread-count'] });
    },
  });

  return (
    <div className="relative">
      <button
        onClick={() => setIsOpen(!isOpen)}
        className="relative p-2 text-gray-600 hover:text-gray-900"
      >
        <svg className="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M15 17h5l-1.405-1.405A2.032 2.032 0 0118 14.158V11a6.002 6.002 0 00-4-5.659V5a2 2 0 10-4 0v.341C7.67 6.165 6 8.388 6 11v3.159c0 .538-.214 1.055-.595 1.436L4 17h5m6 0v1a3 3 0 11-6 0v-1m6 0H9" />
        </svg>
        {unreadCount > 0 && (
          <span className="absolute top-0 right-0 block h-2 w-2 rounded-full bg-red-500 ring-2 ring-white" />
        )}
      </button>

      {isOpen && (
        <div className="absolute right-0 mt-2 w-80 bg-white rounded-lg shadow-lg z-50">
          <div className="p-4 border-b flex justify-between items-center">
            <h3 className="font-semibold">Notifications</h3>
            {unreadCount > 0 && (
              <button
                onClick={() => markAllAsReadMutation.mutate()}
                className="text-sm text-blue-600 hover:text-blue-800"
              >
                Mark all as read
              </button>
            )}
          </div>
          <div className="max-h-96 overflow-y-auto">
            {notifications.length === 0 ? (
              <div className="p-4 text-center text-gray-500">No notifications</div>
            ) : (
              notifications.map((notification) => (
                <div
                  key={notification.id}
                  className={`p-4 border-b hover:bg-gray-50 ${
                    !notification.read ? 'bg-blue-50' : ''
                  }`}
                  onClick={() => !notification.read && markAsReadMutation.mutate(notification.id)}
                >
                  <div className="flex justify-between">
                    <div className="flex-1">
                      <p className="font-medium">{notification.title}</p>
                      <p className="text-sm text-gray-600">{notification.message}</p>
                      {notification.action_url && (
                        <a
                          href={notification.action_url}
                          className="text-sm text-blue-600 hover:text-blue-800"
                        >
                          {notification.action_text || 'View'}
                        </a>
                      )}
                    </div>
                    {!notification.read && (
                      <span className="h-2 w-2 rounded-full bg-blue-500" />
                    )}
                  </div>
                  <p className="text-xs text-gray-400 mt-2">
                    {new Date(notification.created_at).toLocaleString()}
                  </p>
                </div>
              ))
            )}
          </div>
        </div>
      )}
    </div>
  );
}
```

## Running Reverb Server

### 1. Generate Reverb Credentials (First Time Only)

If you haven't run `reverb:install` yet, run it to generate the credentials:

```bash
php artisan reverb:install
```

This command will:
- Generate random `REVERB_APP_ID`, `REVERB_APP_KEY`, and `REVERB_APP_SECRET`
- Add them to your `.env` file automatically
- Publish the Reverb configuration file

**Note:** The credentials are randomly generated by Laravel - you don't need to get them from anywhere!

### 2. Start Reverb Server

In development, start the Reverb server:

```bash
php artisan reverb:start
```

Reverb will run on `http://localhost:8080` by default (or the port specified in `config/reverb.php`).

### 2. Running in Production

For production, you should run Reverb as a background service using a process manager like Supervisor or systemd.

**Example Supervisor Configuration (`/etc/supervisor/conf.d/reverb.conf`):**
```ini
[program:reverb]
process_name=%(program_name)s_%(process_num)02d
command=php /path/to/your/project/artisan reverb:start --host=0.0.0.0 --port=8080
autostart=true
autorestart=true
stopasgroup=true
killasgroup=true
user=www-data
numprocs=1
redirect_stderr=true
stdout_logfile=/path/to/your/project/storage/logs/reverb.log
stopwaitsecs=3600
```

### 3. Using with Queue Workers

If you're using queues, make sure to run both the queue worker and Reverb server:

```bash
# Terminal 1: Queue Worker
php artisan queue:work

# Terminal 2: Reverb Server
php artisan reverb:start
```

Or use a process manager to run both automatically.

## Alternative: Using Pusher

If you prefer to use Pusher instead of Reverb:

1. Update `.env`:
```env
BROADCAST_CONNECTION=pusher
PUSHER_APP_ID=your-app-id
PUSHER_APP_KEY=your-app-key
PUSHER_APP_SECRET=your-app-secret
PUSHER_APP_CLUSTER=mt1
```

2. Update frontend Echo configuration to use Pusher protocol
3. Sign up at [pusher.com](https://pusher.com) and get credentials

## Testing

### Test Real-time Notifications

1. Open your React app in two browser windows
2. Login as the same user in both
3. Create a notification via API (Postman)
4. Both windows should receive the notification in real-time

### Test Broadcasting Authentication

The `/broadcasting/auth` endpoint requires authentication. Make sure your API client includes the access token in requests.

## Troubleshooting

### Notifications not appearing in real-time

1. Check browser console for WebSocket connection errors
2. Verify Pusher/Soketi is running
3. Check broadcasting configuration
4. Verify channel authorization is working
5. Check network tab for `/broadcasting/auth` requests

### Authentication errors

1. Ensure access token is included in API requests
2. Verify `/broadcasting/auth` endpoint is accessible
3. Check CORS configuration for broadcasting endpoint

## Security Notes

- Private channels require authentication
- Users can only listen to their own notification channel
- Channel authorization is handled in `routes/channels.php`
- Broadcasting authentication uses the same auth system as API

